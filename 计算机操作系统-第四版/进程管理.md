# 进程管理

## 数据结构

每个进程或者每个资源都有一个数据结构`（进程信息表）`，内含指针，它们会形成队列结构方便调用和管理。

![image-20201028142259347](进程管理.assets/image-20201028142259347.png)

进程表被称为PCB。

`PCB进程控制块`的作用是使得一个在多道程序环境下不能独立运行的程序称为一个能独立运行的基本单位。

作用：

* 作为独立运行的基本单位的标志。
* 能实现间断性运行方式。
* 提供进程管理所需要的信息。
* 提供进程调度所需要的信息。
* 实现与其他进程的同步和通信。

包含信息：

* 进程标识符
* 处理机状态 --- 就是寄存器那些资源信息，方便被中断后恢复执行。
* 进程调度信息：进程状态，进程优先级等。。。
* 进程控制信息：
  * 程序和数据地址
  * 进程同步和通信机制（消息队列指针，信号量）
  * 资源清单
  * 链接指针，PCB队列里面的下一个进程的PCB的首地址

PCB的组织方式：

![image-20201028143449470](进程管理.assets/image-20201028143449470.png)

线性方式就很简单了。

* 链接方式：相同状态的进程PCB链接成一个队列
* 索引方式：操作系统根据进程状态不一样，建立索引表，把索引表里面在内存的首地址记录在内存的一些专用单元里面。

![image-20201028143816562](进程管理.assets/image-20201028143816562.png)

## 进程控制

操作系统核心功能：

支撑功能：

* 中断处理
* 时钟管理：比如在时间片用完的时候，时钟管理会产生相关的中断信号等等。
* 原语操作：内核中存在很多的原语（因为有些操作必须要么全做，要么不做，不能中断）。

资源管理功能：

* 进程管理
* 存储器管理
* 设备管理

进程的层次结构：

Linux：

* 子进程继承父进程的所有资源，但是子进程销毁的时候必须归还资源，销毁父进程时也必须销毁子进程，要不会产生僵尸进程。

Windows：

* windows不存在等级关系，每个进程都有一个句柄进行标识，等级相同，同时句柄可以用来控制进程且可以进行传递。

进程 创建：

* 申请PCB，为进程分配标识符
* 为新进程分配资源
* 初始化进程控制块。

进程终止：

* 正常终止
* 异常终止
* 外界干预

进程阻塞（block原句），进程唤醒（wakeup原句），进程挂起（suspend原句），进程激活（active原句）。

我觉得阻塞和挂起的最大差别就是挂起的话会终止进程，保存相关信息，方便将来激活，而阻塞只是简单的进程停止，其对资源的控制和信息都在利用之中。

# 进程控制。

> 其主要目的在于并发执行的程序可以共享系统资源，多个进程为了完成一个任务可以很好的相互合作。

相互制约：

* 间接相互制约：对一些资源入IO等的争夺引起相互制约。
* 直接相互制约：进程的结果相互影响。

临界资源：进程间必须互斥方式访问。

![image-20201119105448187](进程管理.assets/image-20201119105448187.png)

可以看到这个生产者和消费者问题，主要是这个循环缓冲区最开始差点没理解。

这其实就是类似于循环队列。

临界区：代码里面访问临界资源的那段。

## 硬件同步

1. 关中断，这就是在硬件条件上关闭中断，使得在进入临界区操作期间计算机不响应中断。
2. 利用Test-and-Set指令

~~~c
boolean TS(boolean *lock){
 Boolean old;
 old = *lock;
 *lock = TRUE;
 return old;
}
~~~

当`lock=TRUE`的时候表示资源正在使用，`lock=FASLE`的时候，表示资源空闲，这样就相当于形成了一把锁。

~~~c
do{
...
while TS(&lock); 
....
lock = FALSE;
over
}while(TRUE)
~~~

3. 利用`swap`指令实现进程互斥

~~~c
void swap(boolean *a,boolean *b)
{
	boolean temp;
	temp = *a;
	*a = *b;
	*b = temp;
}
~~~

如何实现互斥？

~~~c
do{
	key = TRUE;
	do{
		swap(&lock,&key);
	}while(key!=FALSE);
	.....
	lock=FASLE;
	...
}while(TRUE)
~~~

这其实原理还是跟第二个一样的。但是它们都不符合`让权等待的原则`因为其他访问进程必须不断测试，处于一种`忙等`的状态。

`信号量机制`：

1. 整形信号量
   1. 定义一个整形变量`S`，除了初始化意外，只能由标准的原子操作`wait(S)`和`signal(S)来访问`。
   2. ![image-20201119113350803](进程管理.assets/image-20201119113350803.png)
   3. 可以看出还是不符合`让权等待原则`
2.  记录型信号量
   1. 其特点在于**除了资源数目value意外，还增加一个进程链表list**用于链接所有的等待进程。

~~~c
typedef struct{
	int value;
	struct process_control_block *list;
}semaphore;
~~~

![image-20201119114622644](进程管理.assets/image-20201119114622644.png)

* `block(S->list)`其意思是，把列表进程进行阻塞
* S->value为负值的时候，其绝对值还可以表示表中已经阻塞的进程的数量。
* `wakeup(S->list)`其意思是唤醒列表里面的第一个进程。

那么如何实现互斥呢？

​	当`S->value`的初始值为1的时候，表示只允许一个进程访问临界资源，此时信号量转化为互斥信号量。`可以看到这符合让权等待原则，不需要进程不断的进行互斥量访问。`

3. `AND`型信号量
   1. 记录性信号量可能引发的`死锁`状态

![image-20201119121610476](进程管理.assets/image-20201119121610476.png)

`AND`型信号量基本思想：

* 将进程在整个运行过程中所需要的所有资源，一次性全部分配给进程.
* 进程使用完资源之后一起释放相关资源。
* 对若干个临界资源的分配采用`原子操作`，要么全分配，要么一个不分配。
* 由`死锁`原理可以知道，这成功避免了上述死锁的发生。

`wait`操作中加上`AND`条件。

![image-20201119122625181](进程管理.assets/image-20201119122625181.png)

4. 信号量集

为了解决上述信号量只能单个操作的问题，此时进程对信号量`S1`的测试值不再是1，而是资源分配的下限值`t1`，要求`S1>=t`(因为，为了操作系统安全，当申请的资源少于某个下限的时候必须进行管制，不予分配)。

对应的`swait`和`ssignal`格式：

![image-20201119124702840](进程管理.assets/image-20201119124702840.png)

d1这些表示，请求的资源数量。

![image-20201119124738315](进程管理.assets/image-20201119124738315.png)

`信号量的应用`

互斥：

![image-20201119135030571](进程管理.assets/image-20201119135030571.png)

利用信号量实现前驱关系：

即是我们可以通过`信号量`来控制程序的执行顺序：

* 进制p1,p2共享信号量'S',其初值为0，
* ![image-20201119135442750](进程管理.assets/image-20201119135442750.png)
  * P2若先别执行，那必定阻塞，只有进程1执行完`signal(S)`才可以执行进程P2.

`管程机制`：

这其实是对`互斥`的一种封装

![image-20201119142444947](进程管理.assets/image-20201119142444947.png)

![image-20201119142548352](进程管理.assets/image-20201119142548352.png)

其实管程表征了共享资源的数据结构及其对数据结构的一组操作过程。

`生产者消费者问题`

![image-20201119180151440](进程管理.assets/image-20201119180151440.png)

![image-20201119180200750](进程管理.assets/image-20201119180200750.png)

核心思想：

* 一个`mutex`向量实现进程互斥。
* 信号量`empty`和`full`的`wait`和`signal`操作成对出现并且分别处于不同的进程里面。
  * 这就导致一个进程被阻塞后必须由另一个进程来唤醒它，这也就确保了不会产生竞争影响。

利用其它思想也可以解决，但是感觉还是`管程`的方式，比较直接，而且简单明了。

`哲学家进餐问题`

感觉跟上面那个一样，就不费时间了。

































